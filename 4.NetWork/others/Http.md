> HTTP 即超文本传输协议，是服务器和浏览器之间的通信语言，也是互联网的基石
**HTTP的版本**

<img src="https://www.stackscale.com/wp-content/uploads/2021/05/HTTP3_http_timeline_Stackscale.jpg" alt="http历史版本" width="400px" />

## HTTP/0.9
当时对于网络请求的数据内容要求不高，并且操作也很简单，一般就只是html文档的传输

**特点**
* 只有一个请求行，没有HTTP请求头和请求体。
* 服务器仅仅返回数据，没有什么头信息
* 服务器返回的是ascii字节流，因为传输的都是html文档，所以使用ascii码是最合适的

## HTTP/1.0
由于随着互联网的蓬勃发展，传递的内容不仅仅是HTML文件了，还包括了 JS、CSS、图片、音频、视频等各种类型的文件，所以文件格式不局限于ascii编码，还应该有其他类型的编码文件。

为了适配各种类型文件的传递，增加了请求头和响应头，以键值对的形式保存，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。

为了让浏览器知道服务器返回的数据是什么类型，这样才方便浏览器针对不同类型进行处理，以及由于传输的文件可能在体积上会比较大，所以良好的压缩方式非常重要，并且互联网的全球化，对于语言版本这些要求也是非常高的，这些都是请求头和响应头需要来做的。

```
// 请求头：
accept: text/html   // 表示期望服务器返回 html 类型的文件
accept-encoding: gzip, deflate, br  // 表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式
accept-Charset: ISO-8859-1,utf-8  // 返回的文件编码是 UTF-8 或者 IOS-8859-1
accept-language: zh-CN,zh // 表示期望页面的优先语言是中文
```

```
// 响应头：
content-encoding: br // 服务器实际的压缩格式
content-type: text/html; charset=UTF-8   // 实际的编码格式
```

**特点**
* 支持多种格式的文件传输
* 增加了请求头和响应头：
  * 缓存 expires
  * 文件压缩方式
  * 文件编码方式
  * 返回的文件类型
  * 支持的语言
  * 等等...
* 状态码 (因为文件变复杂了，所以可能会出现各种状况)


## HTTP/1.1

修改了HTTP/1.0的不足

**改进点**
1. 改进持久连接
HTTP/1.0时代，每进行一次HTTP通信，都需要建立TCP连接、传输HTTP数据和断开TCP连接 这三个阶段。 如果传输的接口数一多，比如商城的图片请求次数非常多，并且一个域名一次性只能开六条tcp连接，这样必定会降低效率。

为了解决这个问题，HTTP / 1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。

持久连接在 HTTP / 1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上 Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接(这是浏览器提供的能力，跟http/1.1倒没有什么关系)。

2. http管线化 (不太好的技术，一些浏览器选择放弃使用)
为了解决TCP队头阻塞问题。将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。

3. 提供虚拟主机的支持
在 HTTP / 1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟机，每个虚拟机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。

因此，HTTP / 1.1 的请求头中增加了 Host 字段，用来表示当前的域名，这样服务器就可以根据不同的 Host 值做不同的处理。

4. 对动态生成的内容提供了完美支持
在设计 HTTP / 1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。

HTTP / 1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。
(大文件上传就是用的这个方法)
5. 客户端 Cookie、安全机制