## 交叉类型

A & B，需要同时满足 A 与 B 两个类型才行。

**关于对象的合并**

```ts
interface NameStruct {
  name: string;
}

interface AgeStruct {
  age: number;
}

type ProfileStruct = NameStruct & AgeStruct;
const profile: ProfileStruct = {
  name: "xxx",
  age: 18,
};
```

**关于原始类型的合并**

```ts
type StrAndNum = string & number; // never; 描述根本不存在的类型
```

**对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并**

```ts
type Struct1 = {
  primitiveProp: string;
  objectProp: {
    name: string;
  };
};

type Struct2 = {
  primitiveProp: number;
  objectProp: {
    age: number;
  };
};

type Composed = Struct1 & Struct2;

type PrimitivePropType = Composed["primitiveProp"]; // never
type ObjectPropType = Composed["objectProp"]; // { name: string; age: number; }
```

**两个联合类型的交叉类型**
其实还是类似的思路，既然只需要实现一个联合类型成员就能认为是实现了这个联合类型，那么各实现两边联合类型中的一个就行了，也就是两边联合类型的交集：

```ts
type UnionIntersection1 = (1 | 2 | 3) & (1 | 2); // 1 | 2
type UnionIntersection2 = (string | number | symbol) & string; // string
```

联合类型只需要符合成员之一即可（||），而交叉类型需要严格符合每一位成员（&&）

## 索引签名类型

索引签名类型主要指的是在接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构：

```ts
interface AllStringTypes {
  [key: string]: string;
}

type AllStringTypes = {
  [key: string]: string;
};
```

这时，即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 string 类型：

```ts
interface AllStringTypes {
  [key: string]: string;
}

type PropType1 = AllStringTypes["linbudu"]; // string
type PropType2 = AllStringTypes["599"]; // string
```

但由于 `JavaScript` 中，对于 `obj[prop]` 形式的访问会将数字索引访问转换为字符串索引访问，也就是说， `obj[599]` 和 `obj['599']` 的效果是一致的。因此，在字符串索引签名类型中我们仍然可以声明数字类型的键。类似的，symbol 类型也是如此：

```ts
const foo: AllStringTypes = {
  linbudu: "599",
  599: "linbudu",
  [Symbol("ddd")]: "symbol",
};
```

### 索引类型查询

`keyof` 操作符。严谨地说，它可以将对象中的所有键转换为对应**字面量类型**，然后再组合成联合类型。注意，这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然保持为数字类型字面量。

```ts
interface Foo {
  linbudu: 1;
  599: 2;
}

type FooKeys = keyof Foo; // "linbudu" | 599
```

你还可以直接 `keyof any` 来生产一个联合类型，它会由所有可用作对象键值的类型组成：`string | number | symbol`。也就是说，它是由无数字面量类型组成的，由此我们可以知道， `keyof` 的产物**必定是**一个联合类型。

### 索引类型访问

在 JavaScript 中我们可以通过 obj[expression] 的方式来动态访问一个对象属性（即计算属性），expression 表达式会先被执行，然后使用返回值来访问属性。而 TypeScript 中我们也可以通过类似的方式，只不过这里的 expression 要换成类型。接下来，我们来看个例子：

```ts
interface NumberRecord {
  [key: string]: number;
}

type PropType = NumberRecord[string]; // number
```

更直观的例子是通过字面量类型来进行索引类型访问：

```ts
interface Foo {
  propA: number;
  propB: boolean;
}

type PropAType = Foo["propA"]; // number
type PropBType = Foo["propB"]; // boolean
```

更牛逼的操作

```ts
interface Foo {
  propA: number;
  propB: boolean;
  propC: string;
}

type PropTypeUnion = Foo[keyof Foo]; // string | number | boolean
```

### 映射类型：类型编程的第一步

```ts
type Stringify<T> = {
  [K in keyof T]: string;
};

interface Foo {
  prop1: string;
  prop2: number;
  prop3: boolean;
  prop4: () => void;
}

type StringifiedFoo = Stringify<Foo>;

// 等价于
interface StringifiedFoo {
  prop1: string;
  prop2: string;
  prop3: string;
  prop4: string;

```

上述的伪代码：

```ts
const StringifiedFoo = {};
for (const k of Object.keys(Foo)) {
  StringifiedFoo[k] = string;
}
```
