## 类的类型表示

属性的类型标注类似于变量，而构造函数、方法、存取器的类型标注类似于函数

```ts
class Foo {
  prop: string;

  constructor(inputProp: string) {
    this.prop = inputProp;
  }

  print(addon: string): void {
    console.log(`${this.prop} and ${addon}`);
  }

  get propA(): string {
    return `${this.prop}+A`;
  }

  set propA(value: string) {
    this.prop = `${value}+A`;
  }
}
```

唯一需要注意的是，`setter` 方法不允许进行返回值的类型标注，你可以理解为 `setter` 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致

### 修饰符

在 TS 中，我们能够为`Class`成员添加这些修饰符：`public`/`private`/`protected`/`readonly`
除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符（就和 interface 中的 readonly 意义一致）

这些修饰符应用的位置在成员命名前：

```ts
class Foo {
  private prop: string;

  constructor(inputProp: string) {
    this.prop = inputProp;
  }

  protected print(addon: string): void {
    console.log(`${this.prop} and ${addon}`);
  }

  public get propA(): string {
    return `${this.prop}+A`;
  }

  public set propA(value: string) {
    this.propA = `${value}+A`;
  }
}
```

`public`：此类成员在类、类的实例、子类中都能被访问。
`private`：此类成员仅能在类的内部被访问。
`protected`：此类成员仅能在类与子类中被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即不允许再访问受保护的成员。
当你不显式使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以在构造函数中对参数应用访问性修饰符：

```ts
class Foo {
  constructor(public arg1: string, private arg2: boolean) {}
}

new Foo("linbudu", true);
```

此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。

我们通常不会为构造函数添加修饰符，而是让它保持默认的 public

### 静态成员

在 TS 中，你可以使用`static`关键字来表示一个成员为静态成员

```ts
class Foo {
  static staticHandler() {}
  public instanceHandler() {}
}
```

### 继承、实现、抽象类

```ts
class Base {} // 基类 Base
class Derived extends Base {} // 派生类 Derived
```

基类中的哪些成员能够被派生类访问，完全是由其访问性修饰符决定的。
派生类中可以访问到使用 `public` 或 `protected` 修饰符的基类成员。还可以通过基类进行访问

```ts
class Base {
  print() {}
}

class Derived extends Base {
  print() {
    super.print();
    // ...
  }
}
```

`TypeScript 4.3` 新增了 `override` 关键字，来确保派生类尝试覆盖的方法一定在基类中存在定义

```ts
class Base {
  printWithLove() {}
}

class Derived extends Base {
  override print() {
    // 报错，因为基类无这个方法
    //...
  }
}
```

### 抽象类

抽象类是对类结构与方法的抽象，简单来说，一个抽象类描述了一个类中应当有哪些成员（属性、方法等），一个抽象方法描述了这一方法在实际实现中的结构

**抽象方法其实描述的就是这个方法的入参类型和返回值类型**

```ts
abstract class AbsFoo {
  abstract absProp: string;
  abstract get absGetter(): string;
  abstract absMethod(name: string): string;
}
```

实现(implements)一个抽象类

```ts
class Foo implements AbsFoo {
  absProp: string = "heyang";

  get absGetter() {
    return "heyang";
  }

  absMethod(name: string) {
    return name;
  }
}
```

对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 `interface`？是的。`interface` 不仅可以声明函数结构，也可以声明类的结构：

```ts
// interface 和 abstract的作用是一样的
interface FooStruct {
  absProp: string;
  get absGetter(): string;
  absMethod(input: string): string;
}

class Foo implements FooStruct {
  absProp: string = "heyang";

  get absGetter() {
    return "heyang";
  }

  absMethod(name: string) {
    return name;
  }
}
```

注意：在 TS 中无法声明静态的抽象成员

## 两个类的类型相比较，仅仅只有实例成员和方法会相比较，构造函数和静态成员不会被检查

```ts
class Animal {
  feet: number;
  constructor(name: string, numFeet: number) {}
}

class Size {
  feet: number;
  constructor(meters: number) {}
}

let a: Animal;
let s: Size;

a = s; // OK
s = a; // OK
```

私有的和受保护的成员必须来自于相同的类。

```ts
class Animal {
  protected feet: number;
}
class Cat extends Animal {}

let animal: Animal;
let cat: Cat;

animal = cat; // ok
cat = animal; // ok

class Size {
  protected feet: number;
}

let size: Size;

animal = size; // ERROR
size = animal; // ERROR
```
