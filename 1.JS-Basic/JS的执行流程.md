## JS 执行流程

```bash
一段JS代码 --> 编译阶段 --> 执行阶段

一段JS代码在执行之前是需要被JS引擎编译的，编译完成之后，才会进入执行阶段。
```

先给出一段普通的 js 代码

```js
showName(); // 函数showName被执行
console.log(myName); // undefined
var myName = "极客时间";
function showName() {
  console.log("函数showName被执行");
}
```

### 编译阶段

**第一部分：变量提升**

```js
var myName = undefined;
function showName() {
  console.log("函数showName被执行");
}
```

<img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" width="300px" />

注意：经过编译后，会生成两部分的内容。 **执行上下文** 和 **可执行代码**
变量提升的内容便保存在执行上下文中的**变量环境**里。
`JavaScript` 引擎会把声明以外的代码编译为**字节码**

### 执行阶段

仍然是 JS 引擎在处理，JS 引擎执行“可执行代码”，按照顺序一行一行的执行
当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。
接下来打印“myName”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myName 变量，并且其值为 undefined，所以这时候就输出 undefined。
接下来执行第 3 行，把“极客时间”赋给 myName 变量，赋值后变量环境中的 myName 属性值改变为“极客时间”，变量环境如下所示：

### 代码中出现相同的变量或者函数怎么办？

在编译阶段就会进行覆盖。
所以，一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数

---

## 编译器和解释器

之所以存在**编译器**和**解释器**，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为**编译型语言**和**解释型语言**

**编译型语言**在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的**二进制文件**，这样每次运行程序时，都可以直接运行该二进制文件，而**不需要再次重新编译**了。比如 `C/C++`、`GO` 等都是编译型语言。

**解释型语言**编写的程序，在**每次运行时都需要通过解释器对程序进行动态解释和执行**。比如 `Python`、`JavaScript` 等都属于解释型语言。

**故 js 是解释型语言**

那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图：

```bash
                             AST之后就是解释器或者编译器能识别的地方了
              词法分析          词义分析              代码优化
编译器：源代码 -----------> AST ----------> 中间代码 -----------> 二进制文件 -----> 执行
              语法分析

               词法分析         词义分析            解释执行
解释器：源代码 -----------> AST ----------> 字节码 ----------> 执行
               语法分析

```

## v8 执行一段 JS 代码

```bash
        词法分析            Ignition           TurboFan(编译执行)
源代码 ----------> AST --------------->  字节码 -----------> 机器码
        语法分析   执行上下文                |
                                          | (逐行解释执行)
                                          v
                                        机器码
```

从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan

### 生成抽象语法树（AST）和执行上下文

首先是将源代码转换成抽象语法树，并生成执行上下文。
高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 `AST` 了。编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码

AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转换为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。

#### 第一阶段：分词(tokenize),又被称为词法分析

其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串
<img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9AV8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84/img/token-sketch.png"  width="320px" />

从图中可以看出，通过 var myName = '极客时间' 简单地定义了一个变量，其中关键字 var、标识符 myName、赋值运算符 =、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。

#### 第二阶段：解析(parse), 又称为语法分析

根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

**注意：有了 AST 之后，那接下来 V8 就会生成该段代码的执行上下文**

#### 第三阶段：生成字节码

有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要**消耗大量的内存来存放转换后的机器码**。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将近四年的时间，实现了现在的这套架构。

**这也体现除了编译型语言的诟病，即需要大量内存来存放代码，如果是脚本语言全使用编译型方式，那么占用的内存就太恐怖了**

##### 何谓字节码

字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

<img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9AV8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84/img/bytecode-machinecode-contrast.png" width="320px"/>

从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。

#### 第四阶段：执行代码

通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有**热点代码（HotSpot）**，比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

字节码配合解释器和编译器是最近一段时间很火的技术，，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

<img src="https://github.com/w-l-l/BrowserPrinciple/raw/main/V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9AV8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84/img/jit-process.png" width="320px" />
