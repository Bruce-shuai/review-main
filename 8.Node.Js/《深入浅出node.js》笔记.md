## Node 简介

Node 是在 2009 年，由`Ryan Dahl`开发实现的
Ryan Dahl 是一名资深的 C/C++程序员，在创造出 Node 之前，他的主要工作都是围绕**高性能 Web 服务器**进行的。经过一些尝试之后，他找到了设计高性能，Web 服务器的几个要点：事件驱动、异步 I/O。

由于 JS 本身的后端历史包袱少，以及学习成本相较于 c 要更低一些，并且 JS 本身就广泛使用事件驱动，以及 Chrome V8 的超强性能，所以 JS 成为了 Node 的实现语言。

Chrome 浏览器和 Node 的组件构成对比。 浏览器除了 V8 引擎外，还有一个`WebKit`布局引擎。以及浏览器的 API。

```bash
          Chrome                           Node
-------------------------         ------------------------
| HTML                JS |        |      JavaScript      |
| WebKit              V8 |        |         v8           |
|          中间层         |        |        中间层(libuv)  |
| 网卡  硬盘   显卡 ...    |        |       网卡、硬盘...    |
--------------------------        ------------------------
```

除了 `HTML`、`WebKit` 和显卡这些 `UI` 相关技术没有支持外，`Node` 的结构与 `Chrome` 十分相相似，它们都是基于事件驱动的异步结构，浏览器通过事件驱动来服务界面上的交互，`Node`通过事件驱动来服务`I/O`。

在 `Node` 中，`JS` 可以随心所欲的访问本地文件，可以搭建 `webSocket` 服务端，可以连接数据库，还可以如 `Web Workers` 一样玩转多进程。

`Node`打破了过去 JS 只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文交换代价

### 异步 I/O

`Ryan Dahl`排除万难，在底层构建了很多异步`I/O`的 API，从文件读取到网络请求等，均是如此。这样的意义在于，在 Node 中，我们可以从语言层面很自然地进行**并行 I/O**操作。每个调用之间无须等待之前的 I/O 调用结束。

### 单线程

`Node`保持了`JS`在浏览器中单线程的特点。而且在 Node 中，JS 与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。

单线程的弱点：

- 无法利用多核 CPU
- 错误会引起整个应用退出，应用的健壮性值得考验
- 大量计算占用 CPU 导致无法继续调用异步 I/O

像浏览器中 JS 与 UI 共用一个线程一样,JS 长时间执行会导致 UI 的渲染和响应被中断。在 Node 中，长时间的 CPU 占用也会导致后续的异步 I/O 发不出调用，已完成的异步 I/O 的回调函数也会得不到及时执行。
Web Workers 能够创建工作线程来计算，以解决 JS 大计算阻塞 UI 渲染的问题，工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果，这也使得工作线程不能访问到主线程的 UI。
Node 采用了与 Web Workers 相同的思路来解决单线程中大计算量的问题：`child_process`。
子进程的出现，意味着 Node 可以从容应对单线程在健壮性和无法利用多核 CPU 方面的问题。将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果。这可以很好地保持应用模型的简单和低依赖。

### 跨平台

由于在 Node.js 和操作系统之间有了中间层`libuv`即可以实现跨平台。
`libuv` 是由 c++写的，所以跨平台的能力不错

### Node 的应用场景

#### I/O 密集型

I/O 密集的优势主要在于 Node 利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。

#### 是否不擅长 CPU 密集型业务？

Node 在性能上是不俗的(基于 v8)，并且多个语言在计算斐波那契数列的耗时上，Node 的排名也算中等。另一方面，CPU 密集型应用其实也并不可怕。CPU 密集型应用给 Node 的挑战主要是 JS 是单线程的原因，如果 CPU 时间片不能及时释放，使得后续 I/O 无法发起。但是解决办法是可以适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 发起。这样便可以解决。

但是如果是纯计算，并且相当耗时的场景，更适合采用多线程的方式进行计算。解决方法：

- Node 可以通过编写 C/C++扩展的方式高效利用 CPU，这样的性能会比 java 还快
- 可以通过子进程的方式，将一部分 Node 进程当作常驻服务用于计算，然后利用进程间的消息来传递结果，将计算与 I/O 分离。

**CPU 密集并不可怕，如何合理调度才是关键**

#### 例子

- Node 带来的高性能 I/O 用于实时应用：结合 socket.io 用于实时语音、游戏
- 前端工具类的开发：webpack、npm、yarn

## 模块机制

### CommonJS规范

#### 模块引用
```js
const math = require('math');
```

#### 模块定义
在Node中，一个文件就是一个模块(其实，目前在前端界，也是这么定义的)

#### 模块标识
模块标识其实就是传递给`require()`方法的参数，它必须是符合小驼峰命名的字符串，或者以`.、..`开头的相对路径或者绝对路径。它可以没有后缀名js

模块的定义十分简单，接口也十分简单。它的意义在于将类聚的方法和变量等限定在**私有的作用域中**，同时支持引入和导出功能以顺畅地连接上下游依赖。

```js
+-------------+         +---------------+
| module      |         |    module     |
| require  <--|---------|--  exports    |
| exports     |         |               |
|-------------|         |---------------|
```
CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。

### Node的模块使用
在Node中引入模块，需要经历如下3个步骤
1）路径分析
2）文件定位
3）编译执行
在Node中，模块分为两类：一类是Node提供的模块，称为**核心模块**；另一类是用户编写模块，称为**文件模块**。

#### 核心模块
这部分在Node源代码的编译过程中，编译成了**二进制文件**(直接类似编译型语言)，在Node进程启动时，部分核心模块就直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这俩步骤可以省略掉，在路径分析中优先判断，加载速度也是最快的

#### 文件模块
是在**运行时动态加载**的，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

### 模块加载 - 优先从缓存加载
注意：与前端浏览器会缓存静态脚本文件以提高性能一样，`Node`对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方是，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是**核心模块**还是**文件模块**，`require()`方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 路径分析和文件定位

#### 模块标识符分析
`require()`方法接受一个标识符作为参数，在Node实现中，正是基于这样一个标识符进行模块查找的.模块标识符在Node中主要分为以下几类

* 核心模块，如`http`, `fs`, `path`等。
* .或者..开始的相对路径文件模块
* 以 `/` 开始的绝对路径文件模块
* 非路径形式的文件模块，如自定义的`connect`模块

##### 核心模块
其优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。
如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的，如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

##### 路径形式的文件模块
以`.、.. 和 /`开始的标识符，这里都被当做文件模块处理。在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放在缓存中，以使二次加载时速度更快。

##### 自定义模块
自定义模块是指不属于上面两种模块，它是一种特殊的文件模块，可能是一个文件或者包的形式，这类模块的查找是最费时的，也是所有方式中最慢的。



#### 模块路径
模块路径的生成规则
* 当前文件目录下的node_modules目录
* 父目录下的node_module目录
* 沿路径向上逐级递归，直到根目录下的node_modules目录

#### 文件定位
* 文件扩展名分析。
CommonJS模块规范允许在标识符中不包含文件扩展名，这种情况下，Node会按.js，.json，.node的次序补足扩展名


### 模块编译

在Node中，每个文件模块都是一个对象，它的定义如下：
```js
function Module(id, parent) { this.id = id;
this.exports = {}; this.parent = parent;
       if (parent && parent.children) {
         parent.children.push(this);
}
this.filename = null; 
this.loaded = false; 
this.children = [];
}
```

在核心模块中，有些模块全部有C/C++编写，有些模块则有C/C++完成核心部分，其他部分则有JS实现包装或向外导出，以满足性能需求。后面这种C++模块主内完成核心，JS主外实现封装的模式是Node能够提高性能的常见方式。通常，脚本语言的开发速度优于静态语言，但是其性能则弱于静态语言。而Node的这种复合模式可以在开发速度和性能之间找到平衡点