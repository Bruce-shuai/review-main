比较好的文章:https://juejin.cn/post/7129298214959710244

## 常见的前后端鉴权方式
1. http基本鉴权
2. Session-Cookie 
3. Token验证 (包括 JWT SSO)
4. OAuth2.0(开放授权)
5. 扫码登录

## 进一步说话
### HTTP基本鉴权   
数据放在http的authorization里面，以明文的方式进行Basic前后端方式信息交互

#### 优缺点
优点： 简单，所有浏览器都支持

缺点：
* 不安全，以明文的方式裸奔
* 无法主动清除浏览器的Basic认证。


### Session-Cookie鉴权 

略

#### 优缺点
优点：
* cookie简单易用
* 相较于jwt，更方便服务端进行管理，可以轻易控制用户登录注册注销
* cookie的自动附着在http请求里面，所以前端可以无感进行操作

缺点：
* 对cookie的依赖性很高，如果用户浏览器禁用cookie了，就很难办了。
* cookie暴露在浏览器，数据容易被盗(csrf)
* session存储在服务端，增大了服务端的开销，用户量大的时候大大降低了服务器性能。
* 对移动端的支持性不好


### Token鉴权
```
    浏览器                        服务器 
    --------1.username&password------->
                                 2. 检验用户名和密码
                                生成一个加密后的token令牌
    <----------3.返回token-------------
4. 客户端获取token
并保存至本地
    --------5.再次请求API数据时，-------->   6. 拿到token后，做解密和校验
            携带token至服务端  
    <------7.校验成功，返回数据----------
             （校验失败，拒绝返回则401）
```

#### 优缺点
优点：
* 服务端无状态，可扩展，有利于多个服务器共享用户状态（不需要存储会话(session)信息，因为Token自身包含了其所表示用户的相关信息）
* 安全性好，可以避免CSRF攻击
* 支持跨端、跨域

缺点：
* token有效期短(为了避免Token被盗用)
* 需要前后端配合处理
* 后端对于用户的账号控制并不是那么的好

#### refresh Token
用来获取 Access Token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 Session 一样处理；

```
    浏览器                         服务器 
     -----1.username&password-------->
                                 2.校验用户名和密码
                              生成Access Token 和 Refresh Token
     <----3.返回 Access Token&Refresh Token
4. 客户端保存
AccessToken&RefreshToken
到本地  
     -----5.请求API数据时，携带AccessToken->
                                  6. 校验Access Token 是否有效 
    <----7.1.有效：则返回数据 
    <----7.2.失效，校验失败
8.开始刷新Token ----> Refresh Token ---->
                                  9. 校验refresh token是否有效，如果refresh token也过期了，只能重新登录 
    <--------10. 返回新的Access Token 
  11. 保存新的Access Token   

```
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac396824cc4b4a88b5f57d84c1f856cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" />

### JWT 鉴权 
Token鉴权需要查库验证token 是否有效，而JWT不用查库或者少查库，直接在服务端进行校验，并且不用查库。因为用户的信息及加密信息在第二部分payload和第三部分签证中已经生成，只要在服务端进行校验就行，并且校验也是JWT自己实现的。

这样每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗；故jwt出现 

---

JWT就是用户登录成功之后，将相关用户信息组成JSON对象，然后对其加密，返回给浏览器，浏览器下次请求时带上这个Token，服务端收到token后，只需验证token合法性即可。


#### 优缺点
优点： jwt中的负载存储了常用信息，所以可以降低服务端查询数据库的次数

### 单点登录(Single Sign On)

但随着企业的发展，一个大型系统里可能包含 n 多子系统，用户在操作不同的系统时，需要多次登录，很麻烦，那么单点登录（SSO) 就可以很好的解决这个问题的，在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。

* 例如登录天猫，淘宝也会自动登录；

#### 同域下的SSO(主域名相同)

列入百度贴吧和百度云盘：`tieba.baidu.com` 和 `pan.baidu.com`  

1. 客户端：用户访问某个子系统时（例如 tieba.baidu.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；

2. 服务端： 登录认证后，服务端把登录用户的信息存储于 `Session` 中，并且附加在响应头的 `Set-Cookie` 字段中，设置 `Cookie` 的 `Domain` 为 `.baidu.com` ；

3. 再次发送请求时，携带主域名 `Domain` 下的 `Cookie` 给服务器，此时服务端就可以通过该 `Cookie` 来验证登录状态了；

(主要是利用`cookie`的`domain`操作)

#### 跨域下的SSO(主域名不相同)
例如：天猫(tmall.com) 和 淘宝(taobao.com) 

利用的是`CAS 中央授权服务`。 有重定向(302)
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a034d58b8db41c6a9a049bc4c0890b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" />

#### 单点登录下的 CAS 认证步骤详解：

1. 客户端： 开始访问系统 A；
2. 系统 A： 发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（sso.com/login?redir…
3. CAS 认证服务： 发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 未登录 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。
4. 客户端： 输入用户名密码进行 CAS 系统认证；
5. CAS 认证服务： 校验用户信息，并且 生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso.com 的域下 ；同时生成一个 授权令牌 ST (Service Ticket) ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：www.taobao.com?token=ST-345678）
6. 系统 A： 拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；

到这里客户端就可以跟系统 A 愉快的交往啦 ~

7. 客户端： 开始访问系统 B；
8. 系统 B： 发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；
9. CAS 认证服务： CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST) ;
10. 系统 B： 拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 交往了 ~




### OAuth 2.0
在我们实际浏览网站的时候，当我们登录的时候除了输入当前网站的账号密码外，我们还发现可以通过第三方的 QQ 或者 微信登录

常见的提供 OAuth 认证服务的厂商： 支付宝、QQ、微信、微博


## 总结：
* `HTTP` 基本认证：适用于内部网络，或者对于安全要求不是很高的网络
* `Session-Cookie` 适用于一般中大型的网站(移动端APP除外)
* `Token` 和 `JWT`都适用于市面上大部分的企业型网站，`JWT`效果要优于`Token`
* 单点登录(SSO) 适用于子系统较多的大型企业网站(例如字节跳动) (需要使用token)
* `OAuth 2.0` 适用于需要快速注册用户型的网站 (需要使用token)
* `扫码登录` 适用于已完成部署了三端的企业 (需要使用token)
* `一键登录` 适用于原生App (需要使用到token)


## 常见的问题

### 使用cookie时需要考虑的问题
* 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性
* 不要存储敏感数据，比如用户密码，账户余额
* 使用 `httpOnly` 在**一定程度**上提高安全性
* 尽量减少 `cookie` 的体积，能存储的数据量不能超过 `4kb`
* 设置正确的 `domain` 和 `path`，减少数据传输
* cookie 无法跨域
* 一个浏览器针对一个网站最多存 `20` 个 `Cookie`，浏览器一般只允许存放 `300` 个 `Cookie`
* 移动端对 `cookie` 的支持不是很好，而 `session` 需要基于 `cookie` 实现，所以移动端常用的是 `token`


### 使用session时需要考虑的问题
* 将 `session` 存储在服务器里面，当用户同时在线量比较多时，这些 `session` 会占据较多的内存，需要在服务端定期的去清理过期的 `session`
* 当网站采用集群部署的时候，会遇到多台 `web` 服务器之间如何做 `session` 共享的问题。因为 `session` 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 `session` 的服务器，那么该服务器就无法拿到之前已经放入到 `session` 中的登录凭证之类的信息了。
* 当多个应用要共享 `session` 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 `cookie` 跨域的处理。
* `sessionId` 是存储在 `cookie` 中的，假如浏览器禁止 `cookie` 或不支持 `cookie` 怎么办？ 一般会把 `sessionId` 跟在 `url` 参数后面即重写 `url`，所以 `session` 不一定非得需要靠 `cookie` 实现
* 移动端对 `cookie` 的支持不是很好，而 `session` 需要基于 `cookie` 实现，所以移动端常用的是 token

### 使用token时需要考虑的问题
* 如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
* token 完全由应用管理，所以它可以避开同源策略
* token 可以避免 CSRF 攻击(因为不需要 cookie 了)  这里的内容需要研究研究
* 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token

### 使用JWT时需要考虑的问题
* 因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
* JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
* JWT 不加密的情况下，不能将秘密数据写入 JWT。
* JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
* JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
* JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
* JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
* 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。
